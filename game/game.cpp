#include "../includes.h"

auto game_class::get_process_id(std::string exe) -> std::uintptr_t {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (Process32First(snapshot, &entry) == TRUE) {
		while (Process32Next(snapshot, &entry) == TRUE) {
			auto a = std::string(&entry.szExeFile[0]);
			if (a.find(exe) != std::string::npos) {
				return entry.th32ProcessID;
			}
		}
	}

	return false;
}

auto game_class::is_running() -> bool {
	auto process = this->get_process_id(this->game_process);
	if (!process) {
		return false;
	}

	this->bdo_process_id = process;

	return true;
}

auto game_class::inject(std::string bytes) -> void {
	NtWriteVirtualMemory = (NtWriteVirtualMemory_fn)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");
	NtReadVirtualMemory = (NtReadVirtualMemory_fn)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtReadVirtualMemory");

	auto process = this->get_process_id(this->game_process);
	if (!process) {
		return;
	}

	static auto get_module_by_name = [&](const char* module_name) -> MODULEENTRY32 {
		MODULEENTRY32 entry = { 0 };
		
		void* snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, process);
		if (!snapshot) {
			return { 0 };
		}

		entry.dwSize = sizeof(entry);

		bool run_module = Module32First(snapshot, &entry);
		while (run_module) {
			if (!strcmp((char*)entry.szModule, module_name)) {
				CloseHandle(snapshot);

				return entry;
			}

			run_module = Module32Next(snapshot, &entry);
		}

		CloseHandle(snapshot);

		return { 0 };
	};

	// this can be used for csgo for example to check if serverbrowser.dll is loaded before injecting our dll
	// so in other games like gta san andreas this is not required
	while (!get_module_by_name(this->game_module.c_str()).modBaseAddr) {
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

	void* file_buffer = VirtualAlloc(NULL, bytes.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	for (std::size_t i = 0; i < bytes.size(); i++) {
		*(uint8_t*)((uintptr_t)file_buffer + i) = bytes[i];
	}

	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)file_buffer;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)file_buffer + pDosHeader->e_lfanew);

	auto handle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, this->bdo_process_id);
	auto far_image = VirtualAllocEx(handle, NULL, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	NtWriteVirtualMemory(handle, far_image, file_buffer, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL);

	PIMAGE_SECTION_HEADER section_header = (PIMAGE_SECTION_HEADER)(pNtHeaders + 1);
	for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
		NtWriteVirtualMemory(handle, (void*)((LPBYTE)far_image + section_header[i].VirtualAddress),
			(void*)((LPBYTE)file_buffer + section_header[i].PointerToRawData), section_header[i].SizeOfRawData, NULL);
	}

	loader_data loader_params;
	loader_params.ImageBase = far_image;
	loader_params.NtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)far_image + pDosHeader->e_lfanew);
	loader_params.BaseReloc = (PIMAGE_BASE_RELOCATION)((LPBYTE)far_image + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	loader_params.ImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)far_image + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	loader_params.fnLoadLibraryA = LoadLibraryA;
	loader_params.fnGetProcAddress = GetProcAddress;

	uint8_t library_loader[]{ 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x3C, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xFC, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x08, 0x89, 0x55, 0xF8, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x04, 0x8B, 0x55, 0xFC, 0x8B, 0x02, 0x2B, 0x41, 0x34, 0x89, 0x45, 0xCC, 0x8B, 0x4D, 0xF8, 0x83, 0x39, 0x00, 0x0F, 0x84, 0x87, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xF8, 0x83, 0x7A, 0x04, 0x08, 0x72, 0x6D, 0x8B, 0x45, 0xF8, 0x8B, 0x48, 0x04, 0x83, 0xE9, 0x08, 0xD1, 0xE9, 0x89, 0x4D, 0xD0, 0x8B, 0x55, 0xF8, 0x83, 0xC2, 0x08, 0x89, 0x55, 0xE0, 0xC7, 0x45, 0xEC, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0x45, 0xEC, 0x83, 0xC0, 0x01, 0x89, 0x45, 0xEC, 0x8B, 0x4D, 0xEC, 0x3B, 0x4D, 0xD0, 0x7D, 0x3C, 0x8B, 0x55, 0xEC, 0x8B, 0x45, 0xE0, 0x0F, 0xB7, 0x0C, 0x50, 0x85, 0xC9, 0x74, 0x2C, 0x8B, 0x55, 0xEC, 0x8B, 0x45, 0xE0, 0x0F, 0xB7, 0x0C, 0x50, 0x81, 0xE1, 0xFF, 0x0F, 0x00, 0x00, 0x8B, 0x55, 0xF8, 0x8B, 0x02, 0x03, 0xC1, 0x8B, 0x4D, 0xFC, 0x03, 0x01, 0x89, 0x45, 0xDC, 0x8B, 0x55, 0xDC, 0x8B, 0x02, 0x03, 0x45, 0xCC, 0x8B, 0x4D, 0xDC, 0x89, 0x01, 0xEB, 0xB3, 0x8B, 0x55, 0xF8, 0x8B, 0x45, 0xF8, 0x03, 0x42, 0x04, 0x89, 0x45, 0xF8, 0xE9, 0x6D, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x0C, 0x89, 0x55, 0xF0, 0x8B, 0x45, 0xF0, 0x83, 0x38, 0x00, 0x0F, 0x84, 0xE4, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF0, 0x03, 0x10, 0x89, 0x55, 0xF4, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF0, 0x03, 0x50, 0x10, 0x89, 0x55, 0xE8, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF0, 0x03, 0x50, 0x0C, 0x52, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x10, 0xFF, 0xD2, 0x89, 0x45, 0xE4, 0x83, 0x7D, 0xE4, 0x00, 0x75, 0x07, 0x33, 0xC0, 0xE9, 0xD6, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0x83, 0x38, 0x00, 0x0F, 0x84, 0x8B, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xF4, 0x8B, 0x11, 0x81, 0xE2, 0x00, 0x00, 0x00, 0x80, 0x74, 0x32, 0x8B, 0x45, 0xF4, 0x8B, 0x08, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x51, 0x8B, 0x55, 0xE4, 0x52, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x14, 0xFF, 0xD1, 0x89, 0x45, 0xD8, 0x83, 0x7D, 0xD8, 0x00, 0x75, 0x07, 0x33, 0xC0, 0xE9, 0x95, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xE8, 0x8B, 0x45, 0xD8, 0x89, 0x02, 0xEB, 0x35, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF4, 0x03, 0x10, 0x89, 0x55, 0xC8, 0x8B, 0x4D, 0xC8, 0x83, 0xC1, 0x02, 0x51, 0x8B, 0x55, 0xE4, 0x52, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x14, 0xFF, 0xD1, 0x89, 0x45, 0xD4, 0x83, 0x7D, 0xD4, 0x00, 0x75, 0x04, 0x33, 0xC0, 0xEB, 0x5E, 0x8B, 0x55, 0xE8, 0x8B, 0x45, 0xD4, 0x89, 0x02, 0x8B, 0x4D, 0xF4, 0x83, 0xC1, 0x04, 0x89, 0x4D, 0xF4, 0x8B, 0x55, 0xE8, 0x83, 0xC2, 0x04, 0x89, 0x55, 0xE8, 0xE9, 0x69, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xF0, 0x83, 0xC0, 0x14, 0x89, 0x45, 0xF0, 0xE9, 0x10, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x04, 0x83, 0x7A, 0x28, 0x00, 0x74, 0x20, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x04, 0x8B, 0x55, 0xFC, 0x8B, 0x02, 0x03, 0x41, 0x28, 0x89, 0x45, 0xC4, 0x6A, 0x00, 0x6A, 0x01, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x52, 0xFF, 0x55, 0xC4, 0xEB, 0x05, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00 };

	void* loader_memory = VirtualAllocEx(handle, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	NtWriteVirtualMemory(handle, loader_memory, &loader_params, sizeof(loader_data), NULL);
	NtWriteVirtualMemory(handle, (void*)((loader_data*)loader_memory + 1), &(library_loader[0]), sizeof(library_loader), NULL);

	print("injected");
	auto thread = CreateRemoteThread(handle, NULL, 0, (LPTHREAD_START_ROUTINE)((loader_data*)loader_memory + 1), loader_memory, 0, NULL);
	if (!thread) {
		return;
	}

	WaitForSingleObject(thread, INFINITE);

	VirtualFreeEx(handle, loader_memory, 0, MEM_RELEASE);
}

auto game_class::encrypt(std::string key, int size_key, std::string& data) -> void {
	for (std::size_t i = 0; i < data.size(); i++) {
		data[i] ^= key[i % size_key];
	}
}

game_class* game;