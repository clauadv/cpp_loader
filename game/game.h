#pragma once
#include "../includes.h"

typedef NTSTATUS(WINAPI* NtWriteVirtualMemory_fn) (HANDLE, PVOID, PVOID, ULONG, PULONG);
typedef HMODULE(__stdcall* pLoadLibraryA)(LPCSTR);
typedef FARPROC(__stdcall* pGetProcAddress)(HMODULE, LPCSTR);

namespace game {
	inline std::uintptr_t process_id;
	inline std::string game_process = "csgo.exe";

	inline std::uintptr_t get_process_id(const std::string& name) {
		PROCESSENTRY32 entry;
		entry.dwSize = sizeof(PROCESSENTRY32);

		const auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		if (Process32First(snapshot, &entry) == TRUE) {
			while (Process32Next(snapshot, &entry) == TRUE) {
				auto a = std::string(&entry.szExeFile[0]);
				if (a.find(name) != std::string::npos) {
					return entry.th32ProcessID;
				}
			}
		}

		return false;
	}

	inline bool is_running() {
		const auto process = get_process_id(game_process);
		if (!process) {
			return false;
		}

		process_id = process;
		return true;
	}

	inline void encrypt(const std::string& key, const std::size_t size, std::string& data) {
		for (std::size_t i = 0; i < data.size(); i++) {
			data[i] ^= key[i % size];
		}
	}

	inline void inject(const std::string& bytes) {
		const auto NtWriteVirtualMemory = reinterpret_cast<NtWriteVirtualMemory_fn>(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory"));

		const auto process = game::get_process_id(game_process);
		if (!process) {
			return;
		}

		void* file_buffer = VirtualAlloc(nullptr, bytes.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		for (std::size_t i = 0; i < bytes.size(); i++) {
			*reinterpret_cast<std::uint8_t*>(reinterpret_cast<uintptr_t>(file_buffer) + i) = bytes[i];
		}

		const auto dos_header = static_cast<PIMAGE_DOS_HEADER>(file_buffer);
		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<LPBYTE>(file_buffer) + dos_header->e_lfanew);

		const auto handle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, game::process_id);
		const auto far_image = VirtualAllocEx(handle, nullptr, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		NtWriteVirtualMemory(handle, far_image, file_buffer, nt_headers->OptionalHeader.SizeOfHeaders, nullptr);

		const auto section_header = reinterpret_cast<PIMAGE_SECTION_HEADER>(nt_headers + 1);
		for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
			NtWriteVirtualMemory(handle, static_cast<void*>(static_cast<LPBYTE>(far_image) + section_header[i].VirtualAddress), static_cast<void*>(static_cast<LPBYTE>(file_buffer) + section_header[i].PointerToRawData), section_header[i].SizeOfRawData, nullptr);
		}

		struct loader_data {
			LPVOID ImageBase;

			PIMAGE_NT_HEADERS NtHeaders;
			PIMAGE_BASE_RELOCATION BaseReloc;
			PIMAGE_IMPORT_DESCRIPTOR ImportDirectory;

			pLoadLibraryA fnLoadLibraryA;
			pGetProcAddress fnGetProcAddress;
		} loader_parameters{};

		loader_parameters.ImageBase = far_image;
		loader_parameters.NtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<LPBYTE>(far_image) + dos_header->e_lfanew);
		loader_parameters.BaseReloc = reinterpret_cast<PIMAGE_BASE_RELOCATION>(static_cast<LPBYTE>(far_image) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		loader_parameters.ImportDirectory = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(static_cast<LPBYTE>(far_image) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
		loader_parameters.fnLoadLibraryA = LoadLibraryA;
		loader_parameters.fnGetProcAddress = GetProcAddress;

		std::uint8_t library_loader[]{ 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x3C, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xFC, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x08, 0x89, 0x55, 0xF8, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x04, 0x8B, 0x55, 0xFC, 0x8B, 0x02, 0x2B, 0x41, 0x34, 0x89, 0x45, 0xCC, 0x8B, 0x4D, 0xF8, 0x83, 0x39, 0x00, 0x0F, 0x84, 0x87, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xF8, 0x83, 0x7A, 0x04, 0x08, 0x72, 0x6D, 0x8B, 0x45, 0xF8, 0x8B, 0x48, 0x04, 0x83, 0xE9, 0x08, 0xD1, 0xE9, 0x89, 0x4D, 0xD0, 0x8B, 0x55, 0xF8, 0x83, 0xC2, 0x08, 0x89, 0x55, 0xE0, 0xC7, 0x45, 0xEC, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0x45, 0xEC, 0x83, 0xC0, 0x01, 0x89, 0x45, 0xEC, 0x8B, 0x4D, 0xEC, 0x3B, 0x4D, 0xD0, 0x7D, 0x3C, 0x8B, 0x55, 0xEC, 0x8B, 0x45, 0xE0, 0x0F, 0xB7, 0x0C, 0x50, 0x85, 0xC9, 0x74, 0x2C, 0x8B, 0x55, 0xEC, 0x8B, 0x45, 0xE0, 0x0F, 0xB7, 0x0C, 0x50, 0x81, 0xE1, 0xFF, 0x0F, 0x00, 0x00, 0x8B, 0x55, 0xF8, 0x8B, 0x02, 0x03, 0xC1, 0x8B, 0x4D, 0xFC, 0x03, 0x01, 0x89, 0x45, 0xDC, 0x8B, 0x55, 0xDC, 0x8B, 0x02, 0x03, 0x45, 0xCC, 0x8B, 0x4D, 0xDC, 0x89, 0x01, 0xEB, 0xB3, 0x8B, 0x55, 0xF8, 0x8B, 0x45, 0xF8, 0x03, 0x42, 0x04, 0x89, 0x45, 0xF8, 0xE9, 0x6D, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x0C, 0x89, 0x55, 0xF0, 0x8B, 0x45, 0xF0, 0x83, 0x38, 0x00, 0x0F, 0x84, 0xE4, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF0, 0x03, 0x10, 0x89, 0x55, 0xF4, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF0, 0x03, 0x50, 0x10, 0x89, 0x55, 0xE8, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF0, 0x03, 0x50, 0x0C, 0x52, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x10, 0xFF, 0xD2, 0x89, 0x45, 0xE4, 0x83, 0x7D, 0xE4, 0x00, 0x75, 0x07, 0x33, 0xC0, 0xE9, 0xD6, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0x83, 0x38, 0x00, 0x0F, 0x84, 0x8B, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xF4, 0x8B, 0x11, 0x81, 0xE2, 0x00, 0x00, 0x00, 0x80, 0x74, 0x32, 0x8B, 0x45, 0xF4, 0x8B, 0x08, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x51, 0x8B, 0x55, 0xE4, 0x52, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x14, 0xFF, 0xD1, 0x89, 0x45, 0xD8, 0x83, 0x7D, 0xD8, 0x00, 0x75, 0x07, 0x33, 0xC0, 0xE9, 0x95, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xE8, 0x8B, 0x45, 0xD8, 0x89, 0x02, 0xEB, 0x35, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x8B, 0x45, 0xF4, 0x03, 0x10, 0x89, 0x55, 0xC8, 0x8B, 0x4D, 0xC8, 0x83, 0xC1, 0x02, 0x51, 0x8B, 0x55, 0xE4, 0x52, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x14, 0xFF, 0xD1, 0x89, 0x45, 0xD4, 0x83, 0x7D, 0xD4, 0x00, 0x75, 0x04, 0x33, 0xC0, 0xEB, 0x5E, 0x8B, 0x55, 0xE8, 0x8B, 0x45, 0xD4, 0x89, 0x02, 0x8B, 0x4D, 0xF4, 0x83, 0xC1, 0x04, 0x89, 0x4D, 0xF4, 0x8B, 0x55, 0xE8, 0x83, 0xC2, 0x04, 0x89, 0x55, 0xE8, 0xE9, 0x69, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xF0, 0x83, 0xC0, 0x14, 0x89, 0x45, 0xF0, 0xE9, 0x10, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x04, 0x83, 0x7A, 0x28, 0x00, 0x74, 0x20, 0x8B, 0x45, 0xFC, 0x8B, 0x48, 0x04, 0x8B, 0x55, 0xFC, 0x8B, 0x02, 0x03, 0x41, 0x28, 0x89, 0x45, 0xC4, 0x6A, 0x00, 0x6A, 0x01, 0x8B, 0x4D, 0xFC, 0x8B, 0x11, 0x52, 0xFF, 0x55, 0xC4, 0xEB, 0x05, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00 };

		const auto loader_memory = VirtualAllocEx(handle, nullptr, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		NtWriteVirtualMemory(handle, loader_memory, &loader_parameters, sizeof(loader_data), nullptr);
		NtWriteVirtualMemory(handle, static_cast<void*>(static_cast<loader_data*>(loader_memory) + 1), &(library_loader[0]), sizeof(library_loader), nullptr);

		if (loader_memory) {
			const auto thread = CreateRemoteThread(handle, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(static_cast<loader_data*>(loader_memory) + 1), loader_memory, 0, nullptr);
			if (!thread) {
				return;
			}

			WaitForSingleObject(thread, INFINITE);
			VirtualFreeEx(handle, loader_memory, 0, MEM_RELEASE);
		}
	}
}